build_save_rgx <- function() {
    regex_state <- str_c("\\b", rgx_trie(states$state_in, group=TRUE), "$")
    regex_street_types <- rgx_trie(street_types$type_in, group=TRUE)
    regex_part_dir <- rgx_trie(street_dirs$dir_in)
    regex_street_dirs <- str_c("(", regex_part_dir, ")")
    which_short <- which(str_length(street_dirs$dir_in) <= 2)
    regex_street_dirs_short <- rgx_trie(street_dirs$dir_in[which_short], group=TRUE)
    regex_unit <- "(?:APT |APARTMENT |UNIT |SUITE |# ?|NO\\.? |STE\\.? )[0-9A-Z]+"

    regex_city = str_c("\\b", rgx_trie(na.omit(unique(nc_addr$city)), group=TRUE), "$")

    regex_street_city <- str_glue(
        "^(\\d+)([A-Z]?)(?: {regex_street_dirs})?\\.?((?: \\S+)+?) ",
        "(?:{regex_street_types})\\.?(?: {regex_street_dirs_short})?\\.?",
        "( {regex_unit})?((?: \\S+)+)"
    )
    regex_street <- str_glue(
        "^(\\d+)([A-Z]?)(?: {regex_street_dirs})?\\.?((?: \\S+)+) ",
        "(?:{regex_street_types})\\.?(?: {regex_street_dirs})?\\.?( {regex_unit})?$"
    )
    regex_street_only <- str_glue(
        "^(?:{regex_street_dirs} )?\\.?(\\S+(?: \\S+)*) ",
        "(?:{regex_street_types})\\.?(?: {regex_street_dirs})?\\.?$"
    )
    regex_poss_saint <- str_glue("\\b(?:{regex_street_types})\\.?( {regex_street_dirs})?\\.?( {regex_unit})? ST\\.? ")

    regex_saints <- str_c(
        "ST\\.? (AGATHA|ALBANS|ALBANS BAY|AMANT|ANN|ANNE|ANSGAR|AUGUSTINE|",
        "BONAVENTURE|BONIFACE|BONIFACIUS|CHARLES|",
        "CLAIR|CLAIR SHORES|CLAIRSVILLE|CLOUD|COLUMBANS|CROIX|CROIX FALLS|",
        "DONATUS|FRANCISVILLE|GABRIEL|GENEVIEVE|",
        "GEORGE ISLAND|GEORGES|GERMAIN|HEDWIG|HELENA ISLAND|HELENS|",
        "HILAIRE|IGNACE|IGNATIUS|INIGOES|JAMES|JO|JOE|JOHN|",
        "JOHNS|JOHNSBURY|JOHNSBURY CENTER|JOHNSVILLE|LANDRY|",
        "LIBORY|LOUIS|MAGDALEN|MARIE|MARIE|MARIES|",
        "MARTINVILLE|MARY|MARY OF THE WOODS|MARYS|MARYS CITY|MEINRAD|",
        "MICHAELS|NAZIANZ|OLAF|ONGE|PAUL|PAUL ISLAND|PAUL PARK|",
        "PAULS|PETER|PETERS|PHILLIP|REGIS|REGIS FALLS|SIMONS ISLAND|",
        "STEPHENS CHURCH|URBANS|VINCENT|VRAIN|XAVIER)$"
    )

    esc <- function(x) {
        x |>
            str_replace_all(fixed("\\."), "\\\\.") |>
            str_replace_all(fixed("\\d"), "\\\\d") |>
            str_replace_all(fixed("\\b"), "\\\\b") |>
            str_replace_all(fixed("\\S"), "\\\\S")
    }

    out <- str_glue('
    # Generated by `R/build_regex.R`: do not edit by hand

    regex_state <- "{esc(regex_state)}"
    regex_street_types <- "{esc(regex_street_types)}"
    regex_street_dirs <- "{esc(regex_street_dirs)}"
    regex_street_dirs_short <- "{esc(regex_street_dirs_short)}"
    regex_street_city <- ""
    regex_street <- ""
    regex_street_only <- ""
    regex_unit <- "{esc(regex_unit)}"
    regex_city <- "{esc(regex_city)}"
    regex_saints <- "{esc(regex_saints)}"
    regex_poss_saint <- ""
    ')
    # regex_street_city <- "{esc(regex_street_city)}"
    # regex_street <- "{esc(regex_street)}"
    # regex_street_only <- "{esc(regex_street_only)}"
    # regex_poss_saint <- "{esc(regex_poss_saint)}"

    cat(out, file="R/regexes.R", append=FALSE)
}


# make a regex trie
# adapted from <https://gist.github.com/vi3k6i5/e3de8313bf1416830f8ab310288e2a50>
rgx_trie <- function(x, escape=TRUE, group=FALSE, reverse=FALSE) {
    pdata = new.env()
    for (patt in x) {
        ref = pdata
        chars = str_split_1(patt, "")
        if (isTRUE(escape))  {
            chars = str_escape(chars)
        }
        if (isTRUE(reverse)) {
            chars = rev(chars)
        }

        for (ch in chars) {
            ref[[ch]]  = if (is.null(ref[[ch]])) new.env() else ref[[ch]]
            ref = ref[[ch]]
        }
        ref[["_"]] = 1L
    }

    to_pattern <- function(pdata) {
        keys = ls(pdata, sorted=TRUE)
        if (length(keys) == 1 && keys[1] == "_") return(NULL)

        terminal = FALSE
        sub_rgx = list()
        chr_rgx = character(0)
        for (k in keys) {
            if (is.environment(pdata[[k]])) {
                recurse = to_pattern(pdata[[k]])
                if (is.null(recurse)) {
                    chr_rgx = c(chr_rgx, k)
                } else {
                    if (isFALSE(reverse)) {
                        sub_rgx = c(sub_rgx, list(c(k, recurse)))
                    } else {
                        sub_rgx = c(list(c(recurse, k)), sub_rgx)
                    }
                }
            } else {
                terminal = TRUE
            }
        }
        chr_only = length(sub_rgx) == 0

        if (length(chr_rgx) == 1) {
            sub_rgx = c(sub_rgx, list(chr_rgx))
        } else if (length(chr_rgx) > 1){
            sub_rgx = c(sub_rgx, list(c("[", chr_rgx, "]")))
        }

        out = character(0)
        if (length(sub_rgx) == 1) {
            out = sub_rgx[[1]]
        } else {
            joined = unlist(lapply(sub_rgx, function(y) {
                c("|", y)
            }))[-1]
            out = c("(?:", joined, ")")
        }

        if (terminal) {
            if (chr_only) {
                out = c(out, "?")
            } else {
                out = c("(?:", out, ")?")
            }
        }

        out
    }

    rgx = to_pattern(pdata)
    if (isTRUE(group)) {
        if (rgx[1] == "(?:") {
            rgx[1] = "("
        } else {
            rgx = c("(", rgx, ")")
        }
    }
    str_flatten(rgx)
}

# utility for viewing
# estr <- function(ee) {
#     nested_env_list <- function(env) {
#         out <- as.list(env)
#         lapply(out, function(x) if (is.environment(x)) nested_env_list(x) else x)
#     }
#     str(nested_env_list(ee))
# }

# correctness testing
test_trie <- function() {
    testthat::expect_equal(
        rgx_trie(c("p", "pe", "pea", "pear", "peak")),
        "p(?:e(?:a[kr]?)?)?"
    )

    x = c("orange", "kumquat", "tangerine", "mandarin", "pomelo", "yuzu",
                  "grapefruit", "lemon", "lime", "bergamot", "citron", "clementine",
                  "satsuma", "tangelo", "mikan", "tangor", "grape",
                  "mint", "peppermint", "spearmint", "basil", "cilantro",
                  "coriander", "chives", "parsley", "oregano", "rosemary", "thyme",
                  "scallion", "ginger", "garlic", "onion", "galangal")
    x0 = head(x, 15)
    x1 = tail(x, -15)

    testthat::expect_equal(rgx_trie(x), rgx_trie(sample(x)))
    testthat::expect_equal(rgx_trie(x, reverse=TRUE), rgx_trie(sample(x), reverse=TRUE))

    rgx_1 = str_c("(", str_flatten(x0, "|"), ")")
    rgx_2 = rgx_trie(x0)
    rgx_3 = rgx_trie(x0, reverse=TRUE)
    testthat::expect_true(all(str_detect(x0, rgx_1)))
    testthat::expect_true(all(str_detect(x0, rgx_2)))
    testthat::expect_true(all(str_detect(x0, rgx_3)))
    testthat::expect_false(all(str_detect(x1, rgx_1)))
    testthat::expect_false(all(str_detect(x1, rgx_2)))
    testthat::expect_false(all(str_detect(x1, rgx_3)))

    rgx_1 = str_c("(", str_flatten(street_dirs$dir_in, "|"), ")")
    rgx_2 = rgx_trie(street_dirs$dir_in)
    rgx_3 = rgx_trie(street_dirs$dir_in, reverse=TRUE)
    testthat::expect_equal(
        str_detect(nc_addr$address, rgx_1),
        str_detect(nc_addr$address, rgx_2)
    )
    testthat::expect_equal(
        str_detect(nc_addr$address, rgx_1),
        str_detect(nc_addr$address, rgx_2)
    )


    # TIMING
    # x = sample(c(toupper(state.name), state.abb, state.name), 1e5, replace=TRUE)
    # x = sample(c(street_types$type_in, state.name), 1e5, replace=TRUE)
    # x = sample(c(regex_street_dirs, state.name), 1e5, replace=TRUE)

    # dict = states$state_in
    # dict = street_types$type_in
    # dict = regex_street_dirs
    # regex1 <- str_c("\\b", rgx_trie(dict, group=TRUE), "$")
    # regex2 <- str_c("\\b", rgx_trie(dict, group=TRUE, reverse=TRUE), "$")
    # regex0 <- dict |>
    #         sort_long_short() |>
    #         # str_c("\\b", mid = _, "$", collapse = "|") |>
    #         str_flatten(collapse = "|") |>
    #         str_replace_all("\\.", "\\\\.") |>
    #         str_c("\\b(", mid = _, ")$")
    #
    # bench::mark(
    #     str_extract(x, regex1),
    #     stringi::stri_reverse(str_extract(stringi::stri_reverse(x), regex2)),
    #     str_extract(x, regex0)
    # )
}
